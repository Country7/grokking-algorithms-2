package main

// Алгоритм быстрой сортировки
// В худшем случае быстрая сортировка работает за время O(n2). Ничуть не лучше сортировки выбором! Но это худший лучай, а в среднем быстрая сортировка выполняется за время O(n log n)
// Это один из самых быстрых существующих алгоритмов сортировки

import (
	"fmt"
)

func quicksort(slices []int) []int {
	if len(slices) < 2 { // базовый случай рекурсии: срезы с 0 и 1 элементом уже "отсортированы"
		return slices
	} else {
		pivot := slices[0] // опорный элемент - первый элемент среза

		var less = []int{}    // переменная под меньшее
		var greater = []int{} // переменная под большее

		for _, num := range slices[1:] { // перебираем остаток массива
			if num < pivot { // если цифра меньше опорной
				less = append(less, num) // добавляем ее в меньшее от опорного
			} else { // иначе
				greater = append(greater, num) // добавляем ее в большее от опорного
			}
		}

		less = append(quicksort(less), pivot) // оправляем на сортировку меньший срез потом добавляем к нему опорный эл-т
		greater = quicksort(greater)          // оправляем на сортировку больший срез

		return append(less, greater...) // возвращаем результат отсортированный
	}
}

func main() {
	slices := []int{21, 10, 3, 5, 7, 12, 35, 54, 23, 42, 9, 27, 78, 97, 81, 64}
	fmt.Println("Не сортированный срез: ", slices)
	fmt.Println("Сортированный срез: ", quicksort(slices))
}
